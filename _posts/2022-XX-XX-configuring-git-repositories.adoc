---
title: Configuring Git repositories
layout: post
author: Pavol Baran
description: >-
  The article describes how to easily contribute to a project using Eclipse Che
categories: []
keywords: ['git', 'repo', 'repository' 'GitHub', 'GitLab', 'Bitbucket']
slug: /@pavol.baran/configuring-git-repositories
---

=== Introduction

With {prod}, you can clone and contribute to a remote repository on popular source code management (SCM) servers like GitHub, GitLab, and Bitbucket. In this blog post, I'll expain how you can start a new workspace with a clone of a public or private repository and how you can commit and push your changes as a contributor to a project.

=== Starting a new workspace with a clone of a public Git repository

Starting a new workspace that will contain a clone of a public Git repository is simple. In this example, I will start a new workspace with a clone of my fork of the link:https://github.com/eclipse-che/blog[Git repository of this blog] on GitHub. (Starting a new workspace with a clone of a public Git repository that is hosted on a GitLab or Bitbucket server would involve the same steps.)

First, I fork the Git repository of this blog so that I can have my own fork to commit and push my changes to.

.Viewing my fork of the Git repository of this blog on GitHub
image::/assets/img/configuring-git-repositories/blog-github-fork.png[My fork of the Git repository of this blog]
{empty}

I can see that this repository contains `devfile.yaml` that provides a specification for a new workspace. (You can read another link:https://che.eclipseprojects.io/2021/10/12/@mario.loriedo-devfile-v2-and-the-devworkspace-operator-p1.html[post in this blog] about `devfile.yaml`.)

Now I copy the URL of the Git repository. I go to the {prod-short} dashboard to paste the URL into the *Import from Git* field. And then, I click *Create & Open*.

.Entering the URL of the Git repository to be cloned to a new workspace
image::/assets/img/configuring-git-repositories/importing-from-git.png[Entering the URL of the Git repository to be cloned to a new workspace]
{empty}

{prod-short} first locates the devfile in the Git repository to be cloned and then creates a new workspace with a clone of the Git repository in it.

.Starting workspace
image::/assets/img/configuring-git-repositories/workspace-starting.png[Starting workspace]
{empty}

When the workspace has started, I can view and edit the blog files in the Che-Theia IDE.

.New workspace with the repository files accessible in Che-Theia
image::/assets/img/configuring-git-repositories/blog-workspace.png[Working on the blog repository files in Che-Theia]
{empty}

=== Contributing to the remote Git repository from the workspace

https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token[GitHub], https://docs.gitlab.com/ee/user/profile/personal_access_tokens.html[GitLab], and https://confluence.atlassian.com/bitbucketserver/personal-access-tokens-939515499.html[Bitbucket] authentication is based on using personal access tokens (PAT). Each user is able to request several PATs with different names, permissions, expiration times, and so on. Those tokens can be used to sign REST API calls and perform Git repository operations. {prod-short} requires a PAT in a Kubernetes secret for starting a new workspace with a clone of a private Git repository in it. From this secret, another secret is automatically generated, allowing authorization for Git operations. The automatically generated secret is mounted into a workspace container as a Git credentials file. You could request a PAT from a Git SCM server and create the secret yourself; however, the preferred method is to use OAuth. With OAuth, {prod-short} can request an access token on your behalf and manage its renewal.

To authenticate my Git operations to a Git SCM server (such as pushing to a remote branch), I need the Git credentials file. I explain how to set up the OAuth authorization in <<Accessing a private Git repository>>.

Now that I can view my project's source code in the Che-Theia IDE, I'll go ahead and make some change in the project source code. I'm creating a new branch called `test` and adding a few empty lines to the `README.md` file.

.Source control options in Che-Theia
image::/assets/img/configuring-git-repositories/source-control.png[Source control in Che-Theia]
{empty}

I must also set my Git user name and user email (if I haven't done so already) that will identify my commits.

.Configuring Git user name and user email in Che-Theia
image::/assets/img/configuring-git-repositories/git-config.png[Git config in Che-Theia]
{empty}

 I commit my changes and push them to the remote Git repository.

.Using the Push option in Che-Theia to push to the test branch
image::/assets/img/configuring-git-repositories/source-control.png[Using the Push option in Che-Theia]
{empty}

From here, I can open a pull request to the https://github.com/eclipse-che/blog[eclipse-che/blog] repository.


=== Accessing a private Git repository

Before you can access a private Git repository, some actions are required from you as a non-privileged user and from your {prod-short} administrator. Those actions are required for configuring the OAuth authorization so that {prod-short} can act on behalf of the user account on the Git SCM server. GitHub and GitLab use OAuth2, whereas Bitbucket uses OAuth1.

==== User side
First, you need to create a reference to {prod-short} in your Git SCM server account:

- https://docs.github.com/en/developers/apps/building-oauth-apps/creating-an-oauth-app[OAuth App] (GitHub)

- https://docs.gitlab.com/ee/integration/oauth_provider.html#authorized-applications[Authorized Application] (GitLab)

- https://confluence.atlassian.com/adminjiraserver/using-applinks-to-link-to-other-applications-938846918.html[Application Link] (Bitbucket)

===== Creating the GitHub OAuth App

Fill the OAuth App details as follows:

* Enter *{prod-short}* as the *Application name*.

* Enter the {prod-short} URL as the *Homepage URL*. The default value is \https://{prod-deployment}-{prod-namespace}.__<domain>__/.

* Enter the {prod-short} OAuth callback URL as the *Authorization callback URL*. The default value is \https://{prod-deployment}-{prod-namespace}.__<domain>__/api/oauth/callback.

Click *Register application* to create the OAuth App.

Click *Generate new client secret* and save the values of the *Client ID* and *Client Secret* because you will provide them to your {prod-short} administrator.

===== Creating the GitLab Authorized Application

Creating the reference on GitLab is similar to how it's done on GitHub. Additionally, you must choose the allowed scopes.

* Enter *{prod-short}* as the *Name*.

* Enter the {prod-short} OAuth callback URL as the *Redirect URI*. The default value is \https://{prod-deployment}-{prod-namespace}.__<domain>__/api/oauth/callback.

* Check the *Confidential* and *Expire* access tokens checkboxes.

* Under *Scopes*, check the `api`, `write_repository`, and `openid` checkboxes.

Click *Save application* to create the Authorized Application.

Copy and save the *Application ID* and *Secret* values because you will provide them to your {prod-short} administrator.

===== Creating the Bitbucket Application Link


Create an RSA key-value pair:
Use a command line to generate the *public-stripped.pub* and *privatepkcs8-stripped.pem* keys in the required format:
----
$ openssl genrsa -out private.pem 2048

$ openssl rsa -in private.pem -pubout > public.pub

$ openssl pkcs8 -topk8 -inform pem -outform pem -nocrypt -in private.pem -out privatepkcs8.pem

$ cat public.pub | sed 's/-----BEGIN PUBLIC KEY-----//g' | sed 's/-----END PUBLIC KEY-----//g' | tr -d '\n' > public-stripped.pub

$ cat privatepkcs8.pem | sed 's/-----BEGIN PRIVATE KEY-----//g' |  sed 's/-----END PRIVATE KEY-----//g' | tr -d '\n' > privatepkcs8-stripped.pem
----


Use a command line to generate a consumer key and a shared secret:

----
$ openssl rand -base64 24 > bitbucket-consumer-key

$ openssl rand -base64 24 > bitbucket-shared-secret
----

Create the *Application* link:

Enter the {prod-short} URL as the *Application URL*. The default value is `https://{prod-deployment}-{prod-namespace}.__<domain>__/ ` .

Click *Create new link*.

Under *The supplied Application URL has redirected once*, check the *Use this URL* checkbox and click *Continue*.

Enter the following details for the *Application* link:

* Enter *{prod-short}* as the *Application Name*.

* Select *Generic Application* as the *Application Type*.

* Enter *{prod-short}* as the *Service Provider Name*.

* Paste the content of the *bitbucket-consumer-key* file as the *Consumer key*.

* Paste the content of the *bitbucket-shared-secret* file as the *Shared secret*.

* Enter `__<bitbucket_server_url>__/plugins/servlet/oauth/request-token` as the *Request Token URL*.

* Enter `__<bitbucket_server_url>__/plugins/servlet/oauth/access-token` as the *Access token URL*.

* Enter `__<bitbucket_server_url>__/plugins/servlet/oauth/authorize` as the *Authorize URL*.

* Check the *Create incoming link* checkbox.

Click *Continue* and enter the following details:

* Paste the content of the *bitbucket_consumer_key* file as the *Consumer Key*.

* Enter *{prod-short}* as the *Consumer name*.

* Paste the content of the *public-stripped.pub* file as the *Public Key*.

Click *Continue*.

This completes your user steps. Additional steps are now required from your {prod-short} administrator.


==== Admin side

After you've created the reference on the Git SCM, your {prod-short} administrator will create the following Kubernetes secret.

===== GitHub and GitLab

Creating a secret for GitHub and GitLab by a {prod-short} administrator is similar. The only difference between them is the inclusion of the `scm-server-endpoint` annotation. The {prod-short} administrator must enter the URL of the GitLab server because {prod-short} supports the on-prem GitLab.

The administrator can apply the secret by using `{orch-cli}` on a command line:

[source, bash]
----
{orch-cli} apply -f - <<EOF
kind: Secret
apiVersion: v1
metadata:
  name: __<...>__ <1>
  namespace: __<...>__ <2>
  labels:
    app.kubernetes.io/part-of: che.eclipse.org
    app.kubernetes.io/component: oauth-scm-configuration
  annotations:
    che.eclipse.org/oauth-scm-server: __<...>__ <3>
    che.eclipse.org/scm-server-endpoint: __<gitlab_server_url>__ <4>
type: Opaque
data:
  id: __<...>__ <5>
  secret: __<...>__ <6>
EOF
----
<1> Depending on your choice of the Git SCM service provider: `github-oauth-config` or `gitlab-oauth-config`.
<2> The {prod-short} namespace. The default is `{prod-namespace}`.
<3> Depending on your choice of the Git SCM service provider: `github` or `gitlab`.
<4> The GitLab server URL (only for GitLab).
<5> Base64 encoded: the GitHub OAuth Client ID or GitLab Application ID.
<6> Base64-encoded: the GitHub OAuth Client Secret or GitLab Client Secret.


==== Bitbucket

A secret for Bitbucket differs from the GitHub and GitLab secrets mainly in the `data` section.

The administrator can apply the secret by using `{orch-cli}` on a command line:

[source, bash]
----
{orch-cli} apply -f - <<EOF
kind: Secret
apiVersion: v1
metadata:
  name: bitbucket-oauth-config
  namespace: __<...>__ <1>
  labels:
    app.kubernetes.io/component: oauth-scm-configuration
    app.kubernetes.io/part-of: che.eclipse.org
  annotations:
    che.eclipse.org/oauth-scm-server: bitbucket
    che.eclipse.org/scm-server-endpoint: __<...>__ <2>
type: Opaque
data:
  private.key: __<...>__ <3>
  consumer.key: __<...>__ <4>
  shared_secret: __<...>__ <5>
EOF
----
<1> The {prod-short} namespace. The default is `{prod-namespace}`.
<2> The Bitbucket server URL.
<3> Base64-encoded content of the `privatepkcs8-stripped.pem` file.
<4> Base64-encoded content of the `bitbucket_consumer_key` file.
<5> Base64-encoded content of the `bitbucket-shared-secret` file.

==== Completing the OAuth authorization

After you set up the reference to {prod-short} and after your {prod-short} administrator sets up the Kubernetes oauth-config secret, you are ready to start a new workspace with a clone of a private Git repository in it by following the steps in <<Starting a new workspace with a clone of a public Git repository>>, except this time using a private repository. You will be redirected to the SCM server oauth site. And after authorizing {prod-short}, your new workspace will be started.

.Authorizing {prod-short} on GitHub
image::/assets/img/configuring-git-repositories/github-oauth.png[GitHub OAuth]
{empty}

.Authorizing {prod-short} on GitLab
image::/assets/img/configuring-git-repositories/gitlab-oauth.png[GitLab OAuth]
{empty}

.Authorizing {prod-short} on Bitbucket
image::/assets/img/configuring-git-repositories/bitbucket-oauth.png[Bitbucket OAuth]
{empty}

