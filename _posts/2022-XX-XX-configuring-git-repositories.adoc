---
title: Configuring Git repositories
layout: post
author: Pavol Baran
description: >-
  The article describes how to easily contribute to a project using Eclipse Che
categories: []
keywords: ['git', 'repo', 'repository' 'GitHub', 'GitLab', 'Bitbucket']
slug: /@pavol.baran/configuring-git-repositories
---

=== Introduction

{prod} allows for accessing and contributing to popular SCM (source code management) servers like GitHub, GitLab and Bitbucket. In this blog post we'll take a look at how one can create workspace from public or private repository, and then how to commit and push your changes, as to contribute to a project.

=== Starting a new workspace with a clone of a public Git repository

Accessing a public Git repository is very straight forward. For example let's create workspace from link:https://github.com/eclipse-che/blog[this blog's repository] on GitHub.

I recommend to first fork the repository, so we can later try commit and push our changes.

.Viewing my fork of the Git repository of this blog on GitHub
image::/assets/img/configuring-git-repositories/blog-github-fork.png[My fork of the Git repository of this blog]
{empty}

In this repo we can find a file called `devfile.yaml` containing specification for our workspace. You should know about the meaning of this file from previous blog posts.

Now just simply copy the git repo URL, paste it in the `Import from Git` part of {prod-short} dashboard and click `Create & Open`.

.Entering the URL of the Git repository to be cloned to a new workspace
image::/assets/img/configuring-git-repositories/importing-from-git.png[Entering the URL of the Git repository to be cloned to a new workspace]
{empty}

{prod-short} should first find the devfile in your repository and then begin to create a workspace based on it.

.Starting workspace
image::/assets/img/configuring-git-repositories/workspace-starting.png[Starting workspace]
{empty}

After successful creation of the workspace, you should be able to read and change the blog's content in {prod} Theia IDE. Accessing public repository from GitLab or Bitbucket would include the same steps.

.Blog workspace opened in Theia
image::/assets/img/configuring-git-repositories/blog-workspace.png[Blog in Theia]
{empty}

=== Contributing to the remote Git repository from the workspace

https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token[GitHub]/
https://docs.gitlab.com/ee/user/profile/personal_access_tokens.html[GitLab]/
https://confluence.atlassian.com/bitbucketserver/personal-access-tokens-939515499.html[Bitbucket]
authentication is based on using personal access tokens (PAT). Each user is able to request several PATs with different names, permissions, expiration times, and so on. Those tokens can be used to sign REST API calls and perform Git repository operations. {prod-short} needs a PAT in form of Kubernetes secret to create workspace from a private repository. From this secret another secret is automatically created, allowing authorization to Git operations. This secret is mounted into a workspace container as a Git credentials file. You could request a PAT from SCM server and create the secret yourself. There is however preferred method through OAuth. With this method {prod-short} can ask for access token on behalf of you and manage its renewal.

So what comes out of all of this? To authenticate your git operations to SCM server (pushing to a remote branch for example) you need the Git credentials file. So continue to <<Accessing a private Git repository>> where we'll talk about setting the OAuth authorization. Completing it will give rise to the credentials secret and from it, file in a workspace container.

So you are back and ready to contribute. I am assuming you have your project opened in {prod} Theia and understand the user interface. Let's do some change in the project. I've created new branch called `test` and added some empty lines to the `README.md` file.

.Source control options in Che-Theia
image::/assets/img/configuring-git-repositories/source-control.png[Source control in Che-Theia]
{empty}

Before you are able to commit any changes, you'll have to set git name and email (if you have not done so already) which will be recorded in any new commits.

.Configuring Git user name and user email in Che-Theia
image::/assets/img/configuring-git-repositories/git-config.png[Git config in Che-Theia]
{empty}

Now the only thing left to do is commit your changes and push them to a remote repository.

.Using the Push option in Che-Theia to push to the test branch
image::/assets/img/configuring-git-repositories/source-control.png[Using the Push option in Che-Theia]
{empty}

From here, I can open a pull request to the https://github.com/eclipse-che/blog[eclipse-che/blog] repository.


=== Accessing a private Git repository

There is some action required both from you as a non-privileged user and from your {prod-short} admin in order to access private Git repository. We are going to configure OAuth authorization so that {prod-short} can act on behalf of your account on SCM server. GitHub and GitLab use OAuth2, while Bitbucket is a little behind, still using OAuth1.

==== User side
First, you need to create a reference to {prod-short} in your Git SCM server account:

- https://docs.github.com/en/developers/apps/building-oauth-apps/creating-an-oauth-app[OAuth App] (GitHub)

- https://docs.gitlab.com/ee/integration/oauth_provider.html#authorized-applications[Authorized Application] (GitLab)

- https://confluence.atlassian.com/adminjiraserver/using-applinks-to-link-to-other-applications-938846918.html[Application Link] (Bitbucket)

===== Creating the GitHub OAuth App

Fill the OAuth App details as follows:

* Enter *{prod-short}* as the *Application name*.

* Enter the {prod-short} URL as the *Homepage URL*. The default value is \https://{prod-deployment}-{prod-namespace}.__<domain>__/.

* Enter the {prod-short} OAuth callback URL as the *Authorization callback URL*. The default value is \https://{prod-deployment}-{prod-namespace}.__<domain>__/api/oauth/callback.

Click *Register application*. The OAuth App should be created, and you should be able to see *Client ID*. After that click on *Generate new client secret* and store the value of the *Client ID* and *Client Secret*. You will have to provide them to {prod-short} admin.

===== Creating the GitLab Authorized Application

Creating the reference on GitLab is similar to how it's done on GitHub. Additionally, you must choose the allowed scopes.

* Enter *{prod-short}* as the *Name*.

* Enter the {prod-short} OAuth callback URL as the *Redirect URI*. The default value is \https://{prod-deployment}-{prod-namespace}.__<domain>__/api/oauth/callback.

* Check the *Confidential* and *Expire* access tokens checkboxes.

* Under *Scopes*, check the `api`, `write_repository`, and `openid` checkboxes.

Click *Save application*. The Authorized Application should be created, and you should be able to see *Application ID* and *Secret*. Copy and store their values, you will have to provide them to {prod-short} admin.

===== Creating the Bitbucket Application Link


Create an RSA key-value pair:
----
openssl genrsa -out private.pem 2048
openssl rsa -in private.pem -pubout > public.pub
openssl pkcs8 -topk8 -inform pem -outform pem -nocrypt -in private.pem -out privatepkcs8.pem
cat public.pub | sed 's/-----BEGIN PUBLIC KEY-----//g' | sed 's/-----END PUBLIC KEY-----//g' | tr -d '\n' > public-stripped.pub
cat privatepkcs8.pem | sed 's/-----BEGIN PRIVATE KEY-----//g' |  sed 's/-----END PRIVATE KEY-----//g' | tr -d '\n' > privatepkcs8-stripped.pem
----

These commands result in creation of some intermediary files which we can ignore, but also _public-stripped.pub_ and _privatepkcs8-stripped.pem_ keys in the format we'll need.

Next, we'll have to create consumer key and shared secret:

----
openssl rand -base64 24 > bitbucket-consumer-key
openssl rand -base64 24 > bitbucket-shared-secret
----

Create the *Application* link:

Type {prod-short} URL as the *Application URL*. The default value is \https://che-eclipse-che.__<domain>__/ and click *[ Create new link ]*.

Under *The supplied Application URL has redirected once*, check the *Use this URL* checkbox and click *Continue*.

Enter the following details for the *Application* link:

* Enter *{prod-short}* as the *Application Name*.

* Select *Generic Application* as the *Application Type*.

* Enter *{prod-short}* as the *Service Provider Name*.

* Paste the content of the *bitbucket-consumer-key* file as the *Consumer key*.

* Paste the content of the *bitbucket-shared-secret* file as the *Shared secret*.

* Enter `__<bitbucket_server_url>__/plugins/servlet/oauth/request-token` as the *Request Token URL*.

* Enter `__<bitbucket_server_url>__/plugins/servlet/oauth/access-token` as the *Access token URL*.

* Enter `__<bitbucket_server_url>__/plugins/servlet/oauth/access-token` as the *Authorize URL*.

* Check the *Create incoming link* checkbox.

Click *Continue* and enter the following details:

* Paste the content of the *bitbucket_consumer_key* file as the *Consumer Key*.

* Enter *{prod-short}* as the *Consumer name*.

* Paste the content of the *public-stripped.pub* file as the *Public Key*.

Click *Continue*.

This completes your user steps. Additional steps are now required from your {prod-short} administrator.


==== Admin side

After you've created the reference on the Git SCM, your {prod-short} administrator will create the following Kubernetes secret.

===== GitHub and GitLab

Creating secret for GitHub and GitLab is similar. The only difference between them is the inclusion of `scm-server-endpoint` annotation. Since on prem GitLab is supported, URL of the GitLab server needs to be provided.

The administrator can apply the secret by using `{orch-cli}` on a command line:

[source, bash]
----
{orch-cli} apply -f - <<EOF
kind: Secret
apiVersion: v1
metadata:
  name: __<...>__ <1>
  namespace: __<...>__ <2>
  labels:
    app.kubernetes.io/part-of: che.eclipse.org
    app.kubernetes.io/component: oauth-scm-configuration
  annotations:
    che.eclipse.org/oauth-scm-server: __<...>__ <3>
    che.eclipse.org/scm-server-endpoint: __<gitlab_server_url>__ <4>
type: Opaque
data:
  id: __<...>__ <5>
  secret: __<...>__ <6>
EOF
----
<1> Depending on your choice of the Git SCM service provider: `github-oauth-config` or `gitlab-oauth-config`.
<2> The {prod-short} namespace. The default is `{prod-namespace}`.
<3> Depending on your choice of the Git SCM service provider: `github` or `gitlab`.
<4> The GitLab server URL (only for GitLab).
<5> Base64 encoded: the GitHub OAuth Client ID or GitLab Application ID.
<6> Base64-encoded: the GitHub OAuth Client Secret or GitLab Client Secret.


==== Bitbucket

A secret for Bitbucket differs from the GitHub and GitLab secrets mainly in the `data` section.

The administrator can apply the secret by using `{orch-cli}` on a command line:

[source, bash]
----
{orch-cli} apply -f - <<EOF
kind: Secret
apiVersion: v1
metadata:
  name: bitbucket-oauth-config
  namespace: __<...>__ <1>
  labels:
    app.kubernetes.io/component: oauth-scm-configuration
    app.kubernetes.io/part-of: che.eclipse.org
  annotations:
    che.eclipse.org/oauth-scm-server: bitbucket
    che.eclipse.org/scm-server-endpoint: __<...>__ <2>
type: Opaque
data:
  private.key: __<...>__ <3>
  consumer.key: __<...>__ <4>
EOF
----
<1> The {prod-short} namespace. The default is `{prod-namespace}`.
<2> The Bitbucket server URL.
<3> Base64-encoded content of the `privatepkcs8-stripped.pem` file.
<4> Base64-encoded content of the `bitbucket_server_consumer_key` file.

==== Completing the OAuth authorization

After creating the reference to {prod-short} and your admin has created the Kubernetes oauth-config secret, you are ready to go ahead and create a workspace from private git repo. Follow the steps in <<Accessing a public Git repository>> except this time use a private repository. You will be redirected to the SCM server oauth site. And after authorizing {prod-short}, your workspace will be created.

.Authorizing {prod-short} on GitHub
image::/assets/img/configuring-git-repositories/github-oauth.png[GitHub OAuth]
{empty}

.Authorizing {prod-short} on GitLab
image::/assets/img/configuring-git-repositories/gitlab-oauth.png[GitLab OAuth]
{empty}

.Authorizing {prod-short} on Bitbucket
image::/assets/img/configuring-git-repositories/bitbucket-oauth.png[Bitbucket OAuth]
{empty}

